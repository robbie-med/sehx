const S=class m{constructor(e=m.levels.INFO,t=""){this.level=e,this.prefix=t}debug(...e){this.level<=m.levels.DEBUG&&console.debug(`[${this.prefix}] [DEBUG]`,...e)}info(...e){this.level<=m.levels.INFO&&console.info(`[${this.prefix}] [INFO]`,...e)}warn(...e){this.level<=m.levels.WARN&&console.warn(`[${this.prefix}] [WARN]`,...e)}error(...e){this.level<=m.levels.ERROR&&console.error(`[${this.prefix}] [ERROR]`,...e)}setLevel(e){this.level=e}getLevel(){return this.level}};S.levels={DEBUG:0,INFO:1,WARN:2,ERROR:3};let g=S;const k=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),A={language:"auto",threads:4,translate:!1};function y(s){const e=String(s).trim().replace(",","."),t=e.split(":").map(Number);if(t.some(Number.isNaN))throw new Error(`Bad time: "${s}"`);let r=0,a=0,i=0;if(t.length===3)[r,a]=t,i=parseFloat(e.split(":").pop()||"0");else if(t.length===2)[a]=t,i=parseFloat(e.split(":").pop()||"0");else throw new Error(`Bad time format: "${s}"`);return Math.floor(((r*60+a)*60+i)*1e3)}function N(s){const e=/^\s*\[?\s*([0-9]{1,2}:[0-9]{2}:(?:[0-9]{2}[.,][0-9]{1,3})|[0-9]{1,2}:[0-9]{2}[.,][0-9]{1,3})\s*-->\s*([0-9]{1,2}:[0-9]{2}:(?:[0-9]{2}[.,][0-9]{1,3})|[0-9]{1,2}:[0-9]{2}[.,][0-9]{1,3})\s*\]?\s*(.*)\s*$/.exec(s);if(!e)throw new Error("Line does not match VTT-like pattern: "+s);const t=e[1],r=e[2],a=e[3]||"",i=y(t),o=y(r);if(o<i)throw new Error("End time is before start time");return{startMs:i,endMs:o,start:t,end:r,text:a}}function T(s){return new Promise(e=>setTimeout(e,s))}function O(s,e){let t=null,r=!1,a=null,i=null;return{timeoutError:()=>new Promise((o,l)=>{i=o,a=l,t=setTimeout(()=>{!r&&a&&(r=!0,a(new Error(e)))},s)}),clear:()=>{t&&(clearTimeout(t),t=null),i&&(i(),i=null),r=!0,a=null}}}function B(s,e=16e3*100){const t=[];for(let r=0;r<s.length;r+=e)t.push(s.subarray(r,r+e));return t}class D{constructor(e,t){this.whisperService=e,this.logger=new g((t==null?void 0:t.logLevel)||g.levels.ERROR,"TranscriptionSession")}async*streaming(e,t={}){const{timeoutMs:r=3e4}=t,a=B(e);let i=0;for await(const o of a){const l=[];let c=null,h=!1,u,p=0;const{timeoutError:b,clear:w}=O(r,"Transcribe timeout"),f=()=>this.whisperService.transcribe(o,n=>{p=n.timeEnd,n.timeStart+=i,n.timeEnd+=i,this.logger.debug("Transcription segment in session:",n),c?(c(n),c=null):l.push(n),w()},t).then(()=>{this.logger.debug("Transcription done in session then"),h=!0,i+=p,w(),c==null||c(void 0)}).catch(n=>{this.logger.debug("Transcription error in session catch:",n),u=n,w(),c==null||c(void 0)});for(f();;){if(u){if(t.restartModelOnError){this.whisperService.restartModel(),f();continue}throw u}if(h)break;if(l.length)yield l.shift();else try{const n=await Promise.race([new Promise(M=>c=M),b()]);n&&(yield n)}catch(n){u=n}}t.sleepMsBetweenChunks&&await T(t.sleepMsBetweenChunks)}}async*streamimg(e,t={}){yield*this.streaming(e,t)}}class L extends EventTarget{on(e,t){return this.addEventListener(e,t),()=>this.removeEventListener(e,t)}emit(e,t){this.dispatchEvent(new CustomEvent(e,{detail:t}))}}class ${constructor(e){this.wasmModule=null,this.instance=null,this.modelFileName="whisper.bin",this.isTranscribing=!1,this.bus=new L,this.modelData=null,this.logger=new g((e==null?void 0:e.logLevel)??g.levels.ERROR,"WhisperWasmService"),e!=null&&e.init&&this.loadWasmScript()}async checkWasmSupport(){return await k()}async loadWasmScript(){this.wasmModule=await(await import("./libmain-D9-QM3iM-CbKsXEQ8.js")).default({print:(e,...t)=>{t.length>0&&this.logger.debug(t),e.startsWith("[")?(this.logger.info(e),this.bus.emit("transcribe",e)):(this.logger.debug(e),this.bus.emit("system_info",e))},printErr:(e,...t)=>{t.length>0&&this.logger.debug(t),this.logger.warn(e),this.bus.emit("transcribeError",e)}})}async initModel(e){if(!await this.checkWasmSupport())throw new Error("WASM is not supported");return this.modelData=e,this.wasmModule&&(this.wasmModule.FS_unlink(this.modelFileName),this.wasmModule.free()),await this.loadWasmScript(),await T(100),this.storeFS(this.modelFileName,e),this.instance=this.wasmModule.init(this.modelFileName),Promise.resolve()}restartModel(){if(!this.modelData)throw new Error("Model not loaded");return this.initModel(this.modelData)}storeFS(e,t){if(!this.wasmModule)throw new Error("WASM module not loaded");try{this.wasmModule.FS_unlink(e)}catch{}this.wasmModule.FS_createDataFile("/",e,t,!0,!0,!0)}async transcribe(e,t,r={}){if(this.isTranscribing)throw new Error("Already transcribing");if(!this.wasmModule)throw new Error("WASM module not loaded");if(!this.instance)throw new Error("WASM instance not loaded");const a=120;e.length>16e3*a&&this.logger.warn("It's not recommended to transcribe audio data that is longer than 120 seconds"),this.isTranscribing=!0;const{language:i="auto",threads:o=4,translate:l=!1}={...A,...r},c=[],h=Date.now();return this.wasmModule.full_default(this.instance,e,i,o,l),await new Promise((u,p)=>{const b=this.bus.on("transcribe",n=>{const{startMs:M,endMs:F,text:x}=N(n.detail),E={timeStart:M,timeEnd:F,text:x,raw:n.detail};c.push(E),t==null||t(E)}),w=setTimeout(()=>{this.isTranscribing=!1,b(),f(),this.logger.error("Transcribe timeout"),p(new Error("Transcribe timeout")),this.bus.emit("transcribeError","Transcribe timeout")},a*2*1e3),f=this.bus.on("transcribeError",n=>{this.isTranscribing=!1,b(),f(),clearTimeout(w),this.logger.debug("Transcribe error",n.detail),u({segments:c,transcribeDurationMs:Date.now()-h})})})}createSession(){return new D(this,{logLevel:this.logger.getLevel()})}}g.levels.ERROR;let v=!1,d=null,R=!1;async function I(s){if("caches"in self){const a=await(await caches.open("sm-models-v1")).match(s);if(a){const i=await a.arrayBuffer();return new Uint8Array(i)}}const e=await fetch(s);if(!e.ok)throw new Error(`Failed to load model at ${s}`);const t=await e.arrayBuffer();return new Uint8Array(t)}function W(s,e){if(e===16e3)return s;const t=e/16e3,r=Math.floor(s.length/t),a=new Float32Array(r);for(let i=0;i<r;i+=1){const o=i*t,l=Math.floor(o),c=Math.min(l+1,s.length-1),h=o-l;a[i]=s[l]*(1-h)+s[c]*h}return a}function U(){if(R)return;R=!0;const s=48e3,e=new Float32Array(480);for(let o=0;o<e.length;o+=1)e[o]=Math.sin(2*Math.PI*1e3*o/s);const t=W(e,s),r=Math.round(e.length*(16e3/s)),a=Math.abs(t.length-r)<=2,i=t.reduce((o,l)=>Math.max(o,Math.abs(l)),0);if(!a||i===0)throw new Error("Resampler validation failed.")}self.onmessage=async s=>{try{if(s.data.type==="init"){if(!d&&(d=new $,!await d.checkWasmSupport()))throw new Error("WebAssembly not supported.");U();const e=await I(s.data.payload.modelUrl);await d.initModel(e),v=!0;const t={type:"ready"};self.postMessage(t);return}if(s.data.type==="transcribe"){if(!v||!d)throw new Error("Whisper worker not initialized.");const e=W(s.data.payload.audio,s.data.payload.sampleRate),t=self.crossOriginIsolated?2:1,i={type:"result",payload:{text:((await d.transcribe(e,void 0,{language:"en",translate:!1,threads:t})).segments??[]).map(o=>o.text).join("").trim(),confidence:0}};self.postMessage(i)}}catch(e){const r={type:"error",payload:{message:e instanceof Error?e.message:"Whisper worker error."}};self.postMessage(r)}};
