const S=class m{constructor(e=m.levels.INFO,t=""){this.level=e,this.prefix=t}debug(...e){this.level<=m.levels.DEBUG&&console.debug(`[${this.prefix}] [DEBUG]`,...e)}info(...e){this.level<=m.levels.INFO&&console.info(`[${this.prefix}] [INFO]`,...e)}warn(...e){this.level<=m.levels.WARN&&console.warn(`[${this.prefix}] [WARN]`,...e)}error(...e){this.level<=m.levels.ERROR&&console.error(`[${this.prefix}] [ERROR]`,...e)}setLevel(e){this.level=e}getLevel(){return this.level}};S.levels={DEBUG:0,INFO:1,WARN:2,ERROR:3};let g=S;const F=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),N={language:"auto",threads:4,translate:!1};function M(s){const e=String(s).trim().replace(",","."),t=e.split(":").map(Number);if(t.some(Number.isNaN))throw new Error(`Bad time: "${s}"`);let r=0,o=0,i=0;if(t.length===3)[r,o]=t,i=parseFloat(e.split(":").pop()||"0");else if(t.length===2)[o]=t,i=parseFloat(e.split(":").pop()||"0");else throw new Error(`Bad time format: "${s}"`);return Math.floor(((r*60+o)*60+i)*1e3)}function k(s){const e=/^\s*\[?\s*([0-9]{1,2}:[0-9]{2}:(?:[0-9]{2}[.,][0-9]{1,3})|[0-9]{1,2}:[0-9]{2}[.,][0-9]{1,3})\s*-->\s*([0-9]{1,2}:[0-9]{2}:(?:[0-9]{2}[.,][0-9]{1,3})|[0-9]{1,2}:[0-9]{2}[.,][0-9]{1,3})\s*\]?\s*(.*)\s*$/.exec(s);if(!e)throw new Error("Line does not match VTT-like pattern: "+s);const t=e[1],r=e[2],o=e[3]||"",i=M(t),a=M(r);if(a<i)throw new Error("End time is before start time");return{startMs:i,endMs:a,start:t,end:r,text:o}}function T(s){return new Promise(e=>setTimeout(e,s))}function x(s,e){let t=null,r=!1,o=null,i=null;return{timeoutError:()=>new Promise((a,c)=>{i=a,o=c,t=setTimeout(()=>{!r&&o&&(r=!0,o(new Error(e)))},s)}),clear:()=>{t&&(clearTimeout(t),t=null),i&&(i(),i=null),r=!0,o=null}}}function A(s,e=16e3*100){const t=[];for(let r=0;r<s.length;r+=e)t.push(s.subarray(r,r+e));return t}class O{constructor(e,t){this.whisperService=e,this.logger=new g((t==null?void 0:t.logLevel)||g.levels.ERROR,"TranscriptionSession")}async*streaming(e,t={}){const{timeoutMs:r=3e4}=t,o=A(e);let i=0;for await(const a of o){const c=[];let l=null,h=!1,u,p=0;const{timeoutError:b,clear:w}=x(r,"Transcribe timeout"),f=()=>this.whisperService.transcribe(a,n=>{p=n.timeEnd,n.timeStart+=i,n.timeEnd+=i,this.logger.debug("Transcription segment in session:",n),l?(l(n),l=null):c.push(n),w()},t).then(()=>{this.logger.debug("Transcription done in session then"),h=!0,i+=p,w(),l==null||l(void 0)}).catch(n=>{this.logger.debug("Transcription error in session catch:",n),u=n,w(),l==null||l(void 0)});for(f();;){if(u){if(t.restartModelOnError){this.whisperService.restartModel(),f();continue}throw u}if(h)break;if(c.length)yield c.shift();else try{const n=await Promise.race([new Promise(E=>l=E),b()]);n&&(yield n)}catch(n){u=n}}t.sleepMsBetweenChunks&&await T(t.sleepMsBetweenChunks)}}async*streamimg(e,t={}){yield*this.streaming(e,t)}}class B extends EventTarget{on(e,t){return this.addEventListener(e,t),()=>this.removeEventListener(e,t)}emit(e,t){this.dispatchEvent(new CustomEvent(e,{detail:t}))}}class D{constructor(e){this.wasmModule=null,this.instance=null,this.modelFileName="whisper.bin",this.isTranscribing=!1,this.bus=new B,this.modelData=null,this.logger=new g((e==null?void 0:e.logLevel)??g.levels.ERROR,"WhisperWasmService"),e!=null&&e.init&&this.loadWasmScript()}async checkWasmSupport(){return await F()}async loadWasmScript(){this.wasmModule=await(await import("./libmain-D9-QM3iM-CbKsXEQ8.js")).default({print:(e,...t)=>{t.length>0&&this.logger.debug(t),e.startsWith("[")?(this.logger.info(e),this.bus.emit("transcribe",e)):(this.logger.debug(e),this.bus.emit("system_info",e))},printErr:(e,...t)=>{t.length>0&&this.logger.debug(t),this.logger.warn(e),this.bus.emit("transcribeError",e)}})}async initModel(e){if(!await this.checkWasmSupport())throw new Error("WASM is not supported");return this.modelData=e,this.wasmModule&&(this.wasmModule.FS_unlink(this.modelFileName),this.wasmModule.free()),await this.loadWasmScript(),await T(100),this.storeFS(this.modelFileName,e),this.instance=this.wasmModule.init(this.modelFileName),Promise.resolve()}restartModel(){if(!this.modelData)throw new Error("Model not loaded");return this.initModel(this.modelData)}storeFS(e,t){if(!this.wasmModule)throw new Error("WASM module not loaded");try{this.wasmModule.FS_unlink(e)}catch{}this.wasmModule.FS_createDataFile("/",e,t,!0,!0,!0)}async transcribe(e,t,r={}){if(this.isTranscribing)throw new Error("Already transcribing");if(!this.wasmModule)throw new Error("WASM module not loaded");if(!this.instance)throw new Error("WASM instance not loaded");const o=120;e.length>16e3*o&&this.logger.warn("It's not recommended to transcribe audio data that is longer than 120 seconds"),this.isTranscribing=!0;const{language:i="auto",threads:a=4,translate:c=!1}={...N,...r},l=[],h=Date.now();return this.wasmModule.full_default(this.instance,e,i,a,c),await new Promise((u,p)=>{const b=this.bus.on("transcribe",n=>{const{startMs:E,endMs:R,text:W}=k(n.detail),y={timeStart:E,timeEnd:R,text:W,raw:n.detail};l.push(y),t==null||t(y)}),w=setTimeout(()=>{this.isTranscribing=!1,b(),f(),this.logger.error("Transcribe timeout"),p(new Error("Transcribe timeout")),this.bus.emit("transcribeError","Transcribe timeout")},o*2*1e3),f=this.bus.on("transcribeError",n=>{this.isTranscribing=!1,b(),f(),clearTimeout(w),this.logger.debug("Transcribe error",n.detail),u({segments:l,transcribeDurationMs:Date.now()-h})})})}createSession(){return new O(this,{logLevel:this.logger.getLevel()})}}g.levels.ERROR;let v=!1,d=null;async function L(s){if("caches"in self){const o=await(await caches.open("sm-models-v1")).match(s);if(o){const i=await o.arrayBuffer();return new Uint8Array(i)}}const e=await fetch(s);if(!e.ok)throw new Error(`Failed to load model at ${s}`);const t=await e.arrayBuffer();return new Uint8Array(t)}function $(s,e){if(e===16e3)return s;const t=e/16e3,r=Math.floor(s.length/t),o=new Float32Array(r);for(let i=0;i<r;i+=1){const a=i*t,c=Math.floor(a),l=Math.min(c+1,s.length-1),h=a-c;o[i]=s[c]*(1-h)+s[l]*h}return o}self.onmessage=async s=>{try{if(s.data.type==="init"){if(!d&&(d=new D,!await d.checkWasmSupport()))throw new Error("WebAssembly not supported.");const e=await L(s.data.payload.modelUrl);await d.initModel(e),v=!0;const t={type:"ready"};self.postMessage(t);return}if(s.data.type==="transcribe"){if(!v||!d)throw new Error("Whisper worker not initialized.");const e=$(s.data.payload.audio,s.data.payload.sampleRate),t=self.crossOriginIsolated?2:1,i={type:"result",payload:{text:((await d.transcribe(e,void 0,{language:"en",translate:!1,threads:t})).segments??[]).map(a=>a.text).join("").trim(),confidence:0}};self.postMessage(i)}}catch(e){const r={type:"error",payload:{message:e instanceof Error?e.message:"Whisper worker error."}};self.postMessage(r)}};
